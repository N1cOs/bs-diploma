\anonsection{Заключение}

В ходе выполнения данной работы были изучены особенности сверточных нейронных сетей. Было установлено, что на данный
момент наибольшей точностью распознавания объектов на изображениях обладают методы основанные именно на сверточных
нейронных сетях. Был проведен обзор одношаговых и двухшаговых методов распознавания объектов на изображениях, было 
определенно, что наиболее эффективными методами являются одношаговые методы YOLO. Также был проведен анализ особенностей 
архитектуры КОВР, а именно процессоров архитектуры ARM, которые чаще всего выступают в роли процессоров для КОВР.

Был разработан алгоритм, который позволяет организовать распределенное распознавание объектов на видеоизображениях. Для 
этого были разработаны два основных компонента: планировщик и рабочий. Для планировщика была выбран алгоритм планирования
Round-Robin и после был разработан алгоритм сохранения кадров в правильном порядке, который также учитывает возможные 
потери кадров из-за отказа рабочих или неисправностей в сети. Для компонента рабочего была выбрана библиотека OpenCV,
которая позволяет использовать почти любые модели, разработанные для других библиотек машинного обучения. Для взаимодействия
между компонентами была выбрана библиотека ZeroMQ, которая позволяет обмениваться атомарными сообщениями. Разработанная 
топология также позволяет динамически добавлять новых рабочих прямо во время обработки видео.

При проведении тестирования библиотека OpenCV была собрана вместе с интеграцией с библиотекой Tengine. В результате данная 
интеграция повысила скорость распознавания объектов на значения от 29\% до 51\% в зависимости от разрешения видео и 
выбранной модели. В ходе тестирования были использованы две модели: yolov4-tiny и yolov4-416. Для модели yolov4-416 
наблюдался линейный рост скорости обработки видео при добавлении новых рабочих, в итоге наибольшей скорости удалось 
достичь при 21 рабочем -- 4,22 FPS для разрешения видео 1280х720 и 4,14 FPS при разрешении 1920х1080. Данные значения
демонстрируют рост скорости обработки в 19,18 и 18,81 раза по сравнению с использованием одного узла для разрешений
1280х720 и 1920х1080 соответственно. Для модели yolov4-tiny наибольшей скорости удалось достичь при четырех рабочих, 
дальнейшее добавление рабочих давало незначительное ускорение, либо не давало его вовсе. В результате для данной модели
скорость обработки составила 7,64 FPS и 4,95 FPS для разрешений 1280х720 и 1920х1080, что соответствует росту в 3,97 и 
2,89 раза по сравнению со скоростью обработки на одном узле.

В ходе тестирования модели yolov4-tiny было установлено, что узким местом является планировщик. Для нахождения проблемного
места в рамках самого планировщика был реализован модуль сбора статистики. С помощью данного модуля было установлено, что
узким местом является модуль кодирования кадров и в меньшей степени модуль декодирования кадров. В связи с этим для
улучшения данной работы можно сделать следующее:

\begin{enumerate}
\item для устранения узкого места в кодировании кадров, можно эту задачу также переложить на рабочих, то есть планировщик
должен рассылать сжатые кадры. Рабочие будут сами их декодировать, производить распознавание, отображать результаты и
после отправлять обратно уже закодированные кадры;
\item использовать реализацию кодировщика, которая может использовать все доступные ядра процессора, так как автором 
эмпирически было установлено, что в текущей реализации кодировщик не может потреблять более одного ядра;
\item при изучении спецификации платы было установлено, что на ней имеются аппаратные декодеры для стандартов сжатия
H.264 и H265. Автору работы не удалось в текущей реализации найти способ воспользоваться ими, однако удалось это сделать
при использовании утилиты \emph{ffmpeg}. Небольшие тесты для стандарта H.264 показали, что программная реализация декодирует 
видео со скоростью 80 FPS, в то время как аппаратному декодеру удается достичь 290 FPS, что соответствует приросту в 3.6 раза;
\item для ускорения самой операции распознавания можно установить драйвера для имеющегося на плате графического процессора, 
далее настроить интеграцию с фреймворком OpenCL и после при запуске рабочего установить значение \emph{opencl} для
параметра командной строки \emph{target}.
\end{enumerate}

\clearpage
