\section{Тестирование разработанного алгоритма}

\subsection{Тестовое окружение}

\subsubsection{Структура кластера}

Тестирование будет проводится на кластере, состоящего из 22 одноплатных компьютеров ROCKPro64. Данный одноплатный 
компьютер обладает следующими характеристиками:

\begin{enumerate}
\item центральный процессор имеет два ядра ARM Cortex-A72 с тактовой частотой до 1.8 ГГц и четыре ядра ARM Cortex-A53 
с частотой до 1.4 ГГц \cite{RK3399}. Каждое из ядер поддерживает расширение набора команд NEON;
\item графический процессор ARM Mali-T860MP4 с частой 650 МГц \cite{MALI_GPU}. Не будет задействован при вычислениях, 
так как не удалось установить драйвера для корректной работы;
\item 4 ГБ оперативной памяти LPDDR4 \cite{ROCKPRO64};
\item сетевой интерфейс Ethernet c пропускной способностью до 1 Гбит/с;
\item аппаратный декодер видео для стандартов сжатия H.264 и H265. Не будет использоваться при декодировании видео, так 
как библиотека OpenCV не позволяет выбирать аппаратный декодер.
\end{enumerate}

Узлы кластера объединены в локальную сеть через коммутатор MIKROTIK CRS326-24G-2S+RM. На каждом узле установлена 
операционная система Ubuntu 18.04.4, версия ядра Linux 4.4.

\subsubsection{Схема развертывания}

Для более удобной процедуры развертывания на каждый из узлов кластера был установлен Docker демон. После установки демон
был переключен в swarm режим, и все имеющиеся узлы были объединены в кластер. Одному из узлов была назначена роль 
управляющего (manager), всем остальным узлам была присвоена роль рабочего (worker).

На рисунке \ref{deployment_dgrm} представлена диаграмма развертывания. Рассмотрим каждый из запускаемых сервисов отдельно:

\addimg{deployment_dgrm}{1}{Диаграмма развертывания}{deployment_dgrm}

\begin{enumerate}
\item в первую очередь на узле управляющего запускается сервис \emph{Scheduler}, это непосредственно разработанный 
планировщик. Через 5000 порт планировщик рассылает кадры рабочим, в свою очередь рабочие возвращают результат на 
5001 порт.
\item рабочие узлы содержат несколько сервисов \emph{Worker}, этот сервис занимается распознаванием объектов на кадрах. 
Количество запускаемых экземпляров определяется требуемыми ресурсами выбранной модели;
\item на каждом из узлов запущен сервис \emph{Node Exporter}, задача которого собирать метрики потребляемых ресурсов
на узлах. Данный сервис предоставляет метрики по HTTP по пути \emph{/metrics};
\item на узле управляющего запускается сервис \emph{Prometheus}, который является базой данных временных рядов, 
занимается хранением и сбором метрик со всех узлов кластера;
\item для визуализации собранных метрик используется сервис \emph{Grafana}, который обращается к \emph{Prometheus} за 
требуемыми метриками. Данный контейнер при старте привязывает 3000 порт в контейнере к 3000 порту на узле управляющего, 
тем самым давая возможность подключиться внешним клиентам.
\end{enumerate}

\subsection{Проведение тестирования}

\subsubsection{Тестовые параметры}

Как ранее говорилось на данный момент одними из самых эффективных методов являются одношаговые методы YOLO, поэтому 
были выбраны две модели из последней версии данного метода: yolov4-416 и yolov4-tiny. Модель yolov4-416 это полноценная
модель yolov4 с размером входного окна $(416 \times 416)$. В свою очередь модель yolov4-tiny является легковесной версией 
и предназначена для запуска на КОВР.

В качестве видео с видеохостинга YouTube были загружены два ролика с разрешениями 1280x720 и 1920x1080. Частота кадров
обоих роликов -- 30 кадров в секунду. После загрузки с помощью утилиты \emph{ffmpeg} из данных роликов были вырезаны 
отрывки по 15 секунд. Формат медиаконтейнера mp4, стандарт сжатия -- H.264.

\subsubsection{Тестирование на одном узле}
Для тестирования на одном узле был написан скрипт на языке Python, в котором последовательно читались кадры из входного
видео, далее производилось распознавание, затем результаты отображались на кадре и после кадр записывался в выходной 
файл. Результаты тестирования для моделей yolov4-tiny и yolov4-416 представлены в таблицах \ref{single_node_v4_tiny} и
\ref{single_node_v4} соответственно. При тестировании использовались реализация OpenCV по умолчанию и с интеграцией с 
библиотекой Tengine. Каждый из тестовых сценариев запускался по три раза, после в таблицу заносились усредненные значения.
В качестве основной метрики была выбрана скорость обработки видео, выраженная в количестве обработанных кадров за секунду 
(Frames Per Second, FPS). В столбце \emph{Потребление CPU} показывается общее потребление по всем ядрам процессора, то есть 
максимальное значение равно 600\%.

\begin{table}[H]
    \caption{Результаты тестирования на одном узле для модели yolov4-tiny}\label{single_node_v4_tiny}
    \begin{tabular}{|c|c|c|c|c|c|c|}
        \hline
        \multirow{2}{*}{\begin{tabular}[c]{@{}c@{}}Разрешение\\ видео\end{tabular}} & \multicolumn{2}{c|}{FPS} & \multicolumn{2}{c|}{\begin{tabular}[c]{@{}c@{}}Потребление \\ CPU, \%\end{tabular}} & \multicolumn{2}{c|}{\begin{tabular}[c]{@{}c@{}}Потребление \\ памяти, МБайт\end{tabular}} \\ \cline{2-7} 
                  & OpenCV  & Tengine & OpenCV & Tengine & OpenCV & Tengine \\ \hline
        1280x720  & 1,27    & 1,92    & 336    &   164   &   136  &   272   \\ \hline
        1920x1080 & 1,16    & 1,71    & 316    &   159   &   172  &   314   \\ \hline
    \end{tabular}
\end{table}

\begin{table}[H]
    \caption{Результаты тестирования на одном узле для модели yolov4-416}\label{single_node_v4}
    \begin{tabular}{|c|c|c|c|c|c|c|}
        \hline
        \multirow{2}{*}{\begin{tabular}[c]{@{}c@{}}Разрешение\\ видео\end{tabular}} & \multicolumn{2}{c|}{FPS} & \multicolumn{2}{c|}{\begin{tabular}[c]{@{}c@{}}Потребление \\ CPU, \%\end{tabular}} & \multicolumn{2}{c|}{\begin{tabular}[c]{@{}c@{}}Потребление \\ памяти, МБайт\end{tabular}} \\ \cline{2-7} 
                  & OpenCV  & Tengine & OpenCV & Tengine & OpenCV & Tengine \\ \hline
        1280x720  & 0,17    & 0,22    & 378    &   161   &   656  &   1854  \\ \hline
        1920x1080 & 0,16    & 0,22    & 375    &   161   &   691  &   1892  \\ \hline
    \end{tabular}
\end{table}

Анализируя результаты можно заметить, что интеграция библиотеки Tengine действительно дает прирост в скорости обработки
видео, в зависимости от параметров прирост FPS составляет от 29\% до 51\%. При чем кажется странным, что данный прирост 
также сопровождается меньшим общим потреблением процессора. На самом деле такое происходит из-за того, что библиотека 
Tengine использует особенность архитектуры ARM процессоров big.LITTLE и перекладывает почти все вычисления на два более 
высокопроизводительных ядра Cortex-A72. Помимо этого кажется неестественным в некоторых случаях большее потребление CPU при 
обработке видео с меньшим разрешением. Такое можно объяснить тем, что функции декодирования/кодирования кадров 
"однопоточные", то есть максимум могут использовать одно ядро процессора, в то время как остальные ядра оказываются
незагруженными, а так как при большем разрешении видео функции декодирования/кодирования кадров будут занимать больше 
времени, то соответственно период незагруженности остальных ядер будет увеличиваться. Стоит отметить, что потребление 
памяти при интеграции Tengine возрастает, причиной этого является использование собственного формата хранения графа
вычислений.

\subsubsection{Тестирование на кластере}
Перед проведением тестирования на кластере нужно для начала определить параметры планировщика. Напомним, что планировщик 
имеет три основных параметра, которые контролируют скорость обработки и потребляемую память: \emph{ReadBufferSize}, 
\emph{RecvBufferSize} и \emph{WriteBufferSize}. Эмпирическим путем для данных параметров была установлена формула 
\ref{sched_params}, при которой во время тестирования не происходило потери кадров

\begin{equation}\label{sched_params}
    \begin{cases}
        ReadBufferSize = 2W \\
        RecvBufferSize=3W \\
        WriteBufferSize=4W
    \end{cases},
\end{equation}
где $W$ -- количество запущенных рабочих.

На рисунках \ref{yolov4_tiny_results} и \ref{yolov4_results} изображены зависимости FPS от количества запущенных рабочих
для моделей yolov4-tiny и yolov4-416 соответственно. Так как ранее было установлено, что интеграция Tengine повышает
скорость обработки видео, поэтому все рабочие были запущены с поддержкой этой библиотеки. Из графиков для модели yolov4-tiny
видно, что увеличение количества рабочих более четырех не дает ощутимого прироста FPS, что свидетельствует о том, что при 
использовании данной модели узким местом является планировщик. Для модели же yolov4-416 планировщик полностью справляется 
с нагрузкой и наблюдается линейный рост FPS от количества рабочих. При попытке запуска нескольких рабочих с моделью yolov4-416
на одном узле наблюдалась нестабильность работы, во время нескольких тестовых запусках начинала сильно вырастать потребляемая 
память, что даже полностью заполняла SWAP раздел и в итоге процесс рабочего принудительно останавливался процессом OOM Killer.

\addimg{yolov4_tiny_results}{0.6}{Зависимость FPS от количества рабочих для модели yolov4-tiny}{yolov4_tiny_results}

\addimg{yolov4_results}{0.6}{Зависимость FPS от количества рабочих для модели yolov4-416}{yolov4_results}

Используя вышеприведенные графики было найдено оптимальное количество рабочих для разных тестовых параметров. В таблице 
\ref{cluster_results} представлены более развернутые результаты. В столбце $\Delta FPS$ показано во сколько раз увеличилось 
FPS по сравнению с обработкой на одном узле.

\begin{table}[H]
    \small
    \begin{adjustwidth}{-1.2cm}{0cm}
        \caption{Результаты тестирования на кластере}\label{cluster_results}
        \begin{tabular}{|c|c|c|l|c|l|c|l|}
            \hline
            \multirow{2}{*}{\begin{tabular}[c]{@{}c@{}}Тестовые\\ параметры\end{tabular}} & \multirow{2}{*}{\begin{tabular}[c]{@{}c@{}}Количество\\ рабочих\end{tabular}} & \multirow{2}{*}{FPS} & \multirow{2}{*}{$\Delta$FPS} & \multicolumn{2}{c|}{\begin{tabular}[c]{@{}c@{}}Среднее потребление \\ CPU, \%\end{tabular}} & \multicolumn{2}{c|}{\begin{tabular}[c]{@{}c@{}}Среднее потребление \\ памяти, МБайт\end{tabular}} \\ \cline{5-8} 
                                                                                          &                                                                               &                      &                        & Планировщик                           & \multicolumn{1}{c|}{Рабочий}                & Планировщик                              & \multicolumn{1}{c|}{Рабочий}                   \\ \hline
            \begin{tabular}[c]{@{}c@{}}1280x720\\ @yolov4-tiny\end{tabular}  &  4  &  7,64 & \multicolumn{1}{c|}{3,97}  & 176 & 189  & 564  & 454  \\ \hline
            \begin{tabular}[c]{@{}c@{}}1920x1080\\ @yolov4-tiny\end{tabular} &  4  &  4,95 & \multicolumn{1}{c|}{2,89}  & 183 & 143  & 784  & 473  \\ \hline
            \begin{tabular}[c]{@{}c@{}}1280x720\\ @yolov4-416\end{tabular}   &  21 &  4,22 & \multicolumn{1}{c|}{19,18} & 149 & 184  & 784  & 1970 \\ \hline
            \begin{tabular}[c]{@{}c@{}}1920x1080\\ @yolov4-416\end{tabular}  &  21 &  4,14 & \multicolumn{1}{c|}{18,81} & 195 & 184  & 1000 & 1980 \\ \hline
        \end{tabular}
    \end{adjustwidth}
\end{table}

\clearpage
